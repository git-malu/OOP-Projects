package lm44_xw47.clientMap;

import lm44_xw47.model.IMapModel2MapViewAdapter;
import map.MapLayer;
import gov.nasa.worldwind.layers.RenderableLayer;
import gov.nasa.worldwind.layers.MarkerLayer;
import common.IUser;
import java.util.Collection;
import common.IChatRoom;
import javax.swing.Timer;
import java.util.Map;
import gov.nasa.worldwind.geom.Position;
import gov.nasa.worldwind.render.GlobeAnnotation;
import gov.nasa.worldwind.render.markers.Marker;
import java.util.ArrayList;
import gov.nasa.worldwind.render.markers.MarkerAttributes;

/**
* Following defines model for the map.
 * 
 * @author Lu Ma
 * @author Xiaojun Wu */
public class ClientMapModel {
	/*package*/ IMapModel2MapViewAdapter _adpt;
	/*package*/ MapLayer _layer = new MapLayer();
	/*package*/ RenderableLayer _renderLayer = new RenderableLayer();
	/*package*/ final MarkerLayer _markerLayer = new MarkerLayer();
	/*package*/ IUser server;
	/*package*/ IUser localUser;
	/*package*/ Collection<IUser> userList;
	/*package*/ Map<IUser, Player> avatarTable = new Hashtable<IUser, Player>();
	/*package*/ Map<IUser, IChatRoom> userTeamTable;
	/*package*/ Ball ball = new Ball();
	private int _timeSlice = 50;
	private Timer _timer = new Timer(_timeSlice, (e) -> {
		//players update
		for (IUser eachUser : userList) {
			Player player = avatarTable.get(eachUser);

			if (player.moving) {
				player.moveTowardDest();
			}

			//remove dead player's annotation from map layer
			if (player.onMap) {
				if (player.dead) {
					_layer.removeAnnotation(player.playerAnnotation);
					player.onMap = false;
				}
			}
		}

		//ball update
		if (ball.ballState == Ball.FLY) {
			ball.moveTowardDest();
		} else if (ball.ballState == Ball.CARRIED) {
			ball.followCarrier();
		}

		this._layer.firePropertyChange(gov.nasa.worldwind.avlist.AVKey.LAYER, null, this);

	});

	/**
	* Start the map model. */
	public void start() {
		// Create and set an attribute bundle.
		ShapeAttributes pathAttrs = new BasicShapeAttributes();
		pathAttrs.setOutlineMaterial(new Material(Color.green));
		pathAttrs.setOutlineWidth(2d);

		// Create a path, set some of its properties and set its attributes.
		ArrayList<Position> pathPositions = new ArrayList<Position>();
		pathPositions.add(Position.fromDegrees(0, -179, 1e4));
		pathPositions.add(Position.fromDegrees(0, -120, 1e4));
		pathPositions.add(Position.fromDegrees(0, -60, 1e4));
		pathPositions.add(Position.fromDegrees(0, 0, 1e4));
		pathPositions.add(Position.fromDegrees(0, 60, 1e4));
		pathPositions.add(Position.fromDegrees(0, 120, 1e4));
		pathPositions.add(Position.fromDegrees(0, 179, 1e4));
		Path path = new Path(pathPositions);
		path.setAttributes(pathAttrs);
		path.setVisible(true);
		path.setAltitudeMode(WorldWind.RELATIVE_TO_GROUND);
		path.setPathType(AVKey.GREAT_CIRCLE);
		_renderLayer.addRenderable(path);

		//marker layer
		_markerLayer.setOverrideMarkerElevation(true);
		_markerLayer.setKeepSeparated(false);
		_markerLayer.setElevation(1000d);
		_markerLayer.setMarkers(ball.markers);

		_adpt.show(_layer);
		_adpt.show(_renderLayer);
		_adpt.show(_markerLayer);
		startGame();
	}

	/**
	* game start */
	public void startGame() {
		//populate avatar list
		for (IUser eachUser : userList) {
			Player newPlayer;
			String name = "";
			try {
				name = eachUser.getName();
			} catch (RemoteException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			System.out.println("team: " + userTeamTable.get(eachUser).getName());

			if (userTeamTable.get(eachUser).getName().equals("NORTH")) {
				newPlayer = new Player(name, Player.NORTH);
			} else {
				newPlayer = new Player(name, Player.SOUTH);
			}

			newPlayer.setBall(ball);
			avatarTable.put(eachUser, newPlayer);
		}

		//put all player annotations on the map
		for (IUser eachUser : userList) {
			Player eachPlayer = avatarTable.get(eachUser);
			_layer.addAnnotation(eachPlayer.playerAnnotation);
		}
		_timer.start();
	}

	/**
	* when game is over, a message will pop up.
	 * 	 * @param message the message that will be displayed on the client screen */
	public void gameOver(String message) {
		System.out.println(message);
		JOptionPane.showMessageDialog(null, message, "outcome", JOptionPane.PLAIN_MESSAGE);
	}

	/**
	* Constructor.
	 * 	 * 
	 * 	 * @param adpt The adapter this model used to communicate with view. */
	public ClientMapModel(IMapModel2MapViewAdapter adpt) {
		_adpt = adpt;
	}

	/**
	* server informs the client which player needs to die
	 * 	 * @param user the user who is going to die */
	public void serverPlayerDie(IUser user) {
		Player player = avatarTable.get(user);
		player.die();
		this._layer.firePropertyChange(gov.nasa.worldwind.avlist.AVKey.LAYER, null, this);
	}

	/**
	* server informs the client to make a player pick up the ball
	 * 	 * @param user the user who is going to pick up the ball */
	public void serverBallPick(IUser user) {
		Player player = avatarTable.get(user);
		player.pickUpBall();
		this._layer.firePropertyChange(gov.nasa.worldwind.avlist.AVKey.LAYER, null, this);
	}

	public ClientMapModel(IMapModel2MapViewAdapter adpt, Collection<IUser> users, Map<IUser, IChatRoom> teamsByUser,
			IUser server, IUser localUser) {
		_adpt = adpt;
		userList = users;
		userTeamTable = teamsByUser;
		this.server = server;
		this.localUser = localUser;
	}

	/**
	* send a click command to the server when user clicks
	 * 	 * 
	 * 	 * @param p The position of the mouse clicked place. */
	public void click(Position p) {
		System.out.println("Mouse clicked at: " + p + " altitude = " + p.getAltitude());
		//send click cmd to server
		sendClickCmdToServer(p);

		this._layer.firePropertyChange(gov.nasa.worldwind.avlist.AVKey.LAYER, null, this);
	}

	/**
	* server informs the client to move a player 
	 * 	 * @param user the user who is going to move
	 * 	 * @param dest moving destination */
	public void serverPlayerMove(IUser user, Position dest) {
		Player player = avatarTable.get(user);
		player.setDestination(dest);
		this._layer.firePropertyChange(gov.nasa.worldwind.avlist.AVKey.LAYER, null, this);
	}

	/**
	* server informs the client to make a player shoot 
	 * 	 * @param user the user who is going to shoot the ball
	 * 	 * @param dest where the ball will fly */
	public void serverBallShoot(IUser user, Position dest) {
		Player player = avatarTable.get(user);
		player.shoot(dest);
		this._layer.firePropertyChange(gov.nasa.worldwind.avlist.AVKey.LAYER, null, this);
	}

	/**
	* send click command to server when client clicks on the map
	 * 	 * @param position */
	public void sendClickCmdToServer(Position position) {
		System.out.println("Click detected.");
		try {
			server.receive(new DataPacketUser<PlayerPostionType>(PlayerPostionType.class,
					new PlayerPostionType(position.getLatitude().degrees, position.getLongitude().degrees), localUser));
		} catch (RemoteException e) {
			e.printStackTrace();
		}
	}

}

/**
* player status and interactions
 * @author Lu Ma */
/*package*/ class Player {
	/*package*/ String playerName = "Player";
	/*package*/ GlobeAnnotation playerAnnotation = new GlobeAnnotation(playerName, Position.fromDegrees(1, 1, 0));
	/*package*/ Position destination = Position.fromDegrees(45, 90, 0);
	/*package*/ Boolean team = NORTH;
	/*package*/ Boolean moving = false;
	/*package*/ Boolean carrying = false;
	/*package*/ Boolean dead = false;
	/*package*/ Boolean onMap = true;
	/*package*/ Ball myBall = null;
	/*package*/ static Boolean NORTH = true;
	/*package*/ static Boolean SOUTH = false;

	public Player() {
	}

	/**
	* player constructor.
	 * 	 * player name and team affiliation should be provided when creating a player
	 * 	 * @param name
	 * 	 * @param team */
	public Player(String name, Boolean team) {
		Position birthPlace;
		this.playerName = name;
		this.team = team;
		System.out.println("team property: " + team);
		if (team) {
			System.out.println("I should born in north");
			birthPlace = Position.fromDegrees(45, 90, 0);
		} else {
			birthPlace = Position.fromDegrees(-45, 90, 0);
		}
		playerAnnotation = new GlobeAnnotation(name, birthPlace);

	}

	@Override
	public String toString() {
		return playerName;
	}

	/**
	* get the position of the player
	 * 	 * @return */
	public Position getPosition() {
		return this.playerAnnotation.getPosition();
	}

	/**
	* make player pick up the ball by updating the status of both the player and the ball */
	public void pickUpBall() {
		myBall.carrier = this;
		myBall.ballState = Ball.CARRIED;
		carrying = true;
	}

	/**
	* make player move toward destination one step further */
	public void moveTowardDest() {
		Position current = this.playerAnnotation.getPosition();
		double cur_lo = current.longitude.degrees;
		double cur_la = current.latitude.degrees;

		double dest_lo = this.destination.longitude.degrees;
		double dest_la = this.destination.latitude.degrees;

		//take the short path, for example, move from longitude -179 to longitude 179, you can just move 2 degrees instead of 2 * 179 degrees
		if (Math.abs(dest_lo - cur_lo) > 180) {
			if (dest_lo < cur_lo) {
				dest_lo += 360;
			} else {
				cur_lo += 360;
			}
		}

		//move only when hypotenuse > 1, otherwise don't move
		double hypotenuse = Math.sqrt(Math.pow((dest_lo - cur_lo), 2) + Math.pow((dest_la - cur_la), 2));
		if (hypotenuse > 1) {
			double delta_lo = (dest_lo - cur_lo) / hypotenuse * 2;
			double delta_la = (dest_la - cur_la) / hypotenuse * 2;
			System.out.println(delta_la);
			current = current.add(Position.fromDegrees(delta_la, delta_lo, 0)); //move forward a bit
			this.playerAnnotation.moveTo(current);
		} else {
			moving = false;
		}
	}

	/**
	* set the player death status to dead */
	public void die() {
		this.dead = true;
	}

	/**
	* set destination and start moving
	 * 	 * @param dest */
	public void setDestination(Position dest) {
		destination = dest;
		moving = true;
	}

	/**
	* set the ball in the game
	 * 	 * @param ball */
	public void setBall(Ball ball) {
		myBall = ball;
	}

	/**
	* make player shoot the ball by updating the destination and flying status of the ball, and carrying status of the player
	 * 	 * @param position */
	public void shoot(Position position) {
		myBall.destination = position;
		myBall.ballState = Ball.FLY;
		carrying = false;
	}

}

/*package*/ class Ball {
	/*package*/ Marker ballMarker = new BasicMarker(Position.fromDegrees(0, 180, 4000), markerAttrs[10]);
	/*package*/ Position destination = Position.fromDegrees(0, 180, 0);
	/*package*/ ArrayList<Marker> markers = new ArrayList<Marker>();
	/*package*/ int ballState = 0;
	/*package*/ static int FLY = 2;
	/*package*/ static int CARRIED = 1;
	/*package*/ static int STOP = 0;
	/*package*/ Player carrier = null;
	private static final MarkerAttributes[] markerAttrs = new BasicMarkerAttributes[] {
			new BasicMarkerAttributes(Material.BLACK, BasicMarkerShape.SPHERE, 1d, 10, 5),
			new BasicMarkerAttributes(Material.MAGENTA, BasicMarkerShape.CUBE, 1d, 10, 5),
			new BasicMarkerAttributes(Material.YELLOW, BasicMarkerShape.CONE, 1d, 10, 5),
			new BasicMarkerAttributes(Material.LIGHT_GRAY, BasicMarkerShape.CYLINDER, 1d, 10, 5),
			new BasicMarkerAttributes(Material.GRAY, BasicMarkerShape.HEADING_ARROW, 1d, 10, 5),
			new BasicMarkerAttributes(Material.WHITE, BasicMarkerShape.HEADING_LINE, 1d, 10, 5),
			new BasicMarkerAttributes(Material.RED, BasicMarkerShape.ORIENTED_CONE_LINE, 0.7),
			new BasicMarkerAttributes(Material.YELLOW, BasicMarkerShape.ORIENTED_CYLINDER_LINE, 0.9),
			new BasicMarkerAttributes(Material.CYAN, BasicMarkerShape.ORIENTED_SPHERE_LINE, 0.7),
			new BasicMarkerAttributes(Material.GREEN, BasicMarkerShape.ORIENTED_CONE, 1d),
			new BasicMarkerAttributes(Material.PINK, BasicMarkerShape.ORIENTED_SPHERE, 0.8, 20, 20),
			new BasicMarkerAttributes(Material.BLUE, BasicMarkerShape.ORIENTED_CYLINDER, 0.6),
			new BasicMarkerAttributes(Material.RED, BasicMarkerShape.ORIENTED_CUBE, 1d) };

	public Ball() {
		markers.add(ballMarker);
	}

	/**
	* get ball's position
	 * 	 * @return */
	public Position getPosition() {
		return this.ballMarker.getPosition();
	}

	/**
	* move the ball one step toward the destination */
	public void moveTowardDest() {
		moveOneStepToward(destination);
	}

	/**
	* make the ball follow the carrier */
	public void followCarrier() {
		ballMarker.setPosition(carrier.playerAnnotation.getPosition());
	}

	/**
	* calculation of moving one step toward destination
	 * 	 * @param position destination */
	public void moveOneStepToward(Position position) {
		Position current = this.ballMarker.getPosition();
		double cur_lo = current.longitude.degrees;
		double cur_la = current.latitude.degrees;

		double dest_lo = position.longitude.degrees;
		double dest_la = position.latitude.degrees;

		//make sure the ball takes the short path, for example, when moving from longitude -179 to longitude 179, you can just move 2 degrees instead of 2 * 179 degrees
		if (Math.abs(dest_lo - cur_lo) > 180) {
			if (dest_lo < cur_lo) {
				dest_lo += 360;
			} else {
				cur_lo += 360;
			}
		}

		double hypotenuse = Math.sqrt(Math.pow((dest_lo - cur_lo), 2) + Math.pow((dest_la - cur_la), 2));

		//move only when hypotenuse > 1, otherwise don't move
		if (hypotenuse > 1) {
			double delta_lo = (dest_lo - cur_lo) / hypotenuse * 2;
			double delta_la = (dest_la - cur_la) / hypotenuse * 2;
			System.out.println(delta_la);
			current = current.add(Position.fromDegrees(delta_la, delta_lo, 0)); //move forward a bit
			this.ballMarker.setPosition(current);
		} else {
			this.ballState = Ball.STOP;
		}
	}

}
