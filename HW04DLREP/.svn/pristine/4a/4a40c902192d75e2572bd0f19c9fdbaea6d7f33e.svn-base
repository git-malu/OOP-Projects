package model;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Point;
import java.util.Observable;
import java.util.Observer;

import model.strategy.IPaintStrategy;
import util.BallCmd;

/**
 * abstract class, used to create a ball
 * @version 1.0.0
 */
public class Ball implements Observer {
	protected Point location; // the location of the ball
	protected int radius; // the radius of the ball
	protected Color color; //the color of the ball
	protected Point velocity; //the velocity of the ball
	protected Point size;
	protected IUpdateStrategy strategyInterface = IUpdateStrategy.nullStrategy; //initialize with null strategy
	protected Component container;
	public int bounce_counter = 0;
	
	private IPaintStrategy _paintStrategy = IPaintStrategy.null_paint ;
	
	/**
	 * constructor
	 * @param l location
	 * @param r radius
	 * @param v velocity
	 * @param c color
	 * @param stra strategy
	 */
	public Ball(Point l, int r, Point v, Color c, Component container, IUpdateStrategy stra, IPaintStrategy paintStrategy) {
		this.location = l;
		this.radius = r;
		this.velocity = v;
		this.color = c;
		this.strategyInterface = stra;
		this._paintStrategy = paintStrategy;
		this.container = container;
		this.size = new Point(2*r, 2*r);
		_paintStrategy.init(this);
	}


  /**
	 * change all sorts of behaviors of the ball
	 * update() executed when notified by the dispatcher
	 * @param o when dispatcher notify, it will take action
	 * @param g graphics
	 */
	public void update(Observable o, Object cmd) {
//		strategyInterface.updateState(this);
//		move();
//		bounce();
//		paint((Graphics) g);
		
		BallCmd command = (BallCmd) cmd;
		command.updateState(this);
		command.move(this);
		command.bounce(this);
		command.paint(this);
	}

	/**
	 * move the ball to a new place according its velocity
	 */
	public void move() {
		location.translate(velocity.x, velocity.y);
	}

	/**
	 * bounce the ball when it hit the bounds, change its speed direction and location
	 */
	public void bounce() {
		if (location.x < 0 || location.x + 2 * radius > BallWorldModel.returnBounds().width) {
			velocity.x = -velocity.x;
			location.x = location.x + 2 * velocity.x;
		}
		if (location.y < 0 || location.y + 2 * radius > BallWorldModel.returnBounds().height) {
			velocity.y = -velocity.y;
			location.y = location.y + 2 * velocity.y;
		}
		
		//new move for affine
//		if(velocity.x>0) {
//			if( (location.x + size.x)> BallWorldModel.returnBounds().width) {
//				
//				velocity.x = -velocity.x;
//				location.x = location.x + 2 * velocity.x;
//				bounce_counter = 1;
//			}
//		}else if((location.x - size.x) < 0){
//			
//			velocity.x = -velocity.x;
//			location.x = location.x + 2 * velocity.x;
//			bounce_counter = 1;
//		}
//		
//		if(velocity.y>0) {
//			if( (location.y + size.y)> BallWorldModel.returnBounds().height) {
//				
//				velocity.y = -velocity.y;
//				location.y = location.y + 2 * velocity.y;
//				bounce_counter = 1;
//			}
//		}else if((location.y - size.y) < 0){
//			velocity.y = -velocity.y;
//			location.y = location.y + 2 * velocity.y;
//			bounce_counter = 1;
//		}
	}
	
	/**
	 * paint a ball on canvas with location location and radius radius
	 * @param g
	 */
	public void paint(Graphics g) {
		g.setColor(color);
		_paintStrategy.paint(g, this);
		//g.fillOval(location.x, location.y, 2 * radius, 2 * radius);
	}
	
	//setter
	void setPaintStrategy(IPaintStrategy pstrategy) {
		_paintStrategy = pstrategy;
		_paintStrategy.init(this);
	}
	//getter
	public IPaintStrategy getPaintStrategy() {
		return _paintStrategy;
	}
	
	/**
	 * set the location
	 * @param n_location
	 */
	public void setLocation(Point n_location) {
		this.location = n_location;
	}

	/**
	 * get the location
	 * @return location
	 */
	public Point getLocation() {
		return location;
	}
	
	public Point getSize(){
		return size;
	}
	/**
	 * set the velocity
	 * @param velocity
	 */
	public void setVelocity(Point velocity) {
		this.velocity = velocity;
	}

	/**
	 * get the velocity
	 * @return velocity
	 */
	public Point getVelocity() {
		return velocity;
	}

	/**
	 * set the color
	 * @param color
	 */
	public void setColor(Color color) {
		this.color = color;
	}

	/**
	 * get the color
	 * @return color
	 */
	public Color getColor() {
		return color;
	}

	/**
	 * set the radius
	 * @param radius
	 */
	public void setRadius(int radius) {
		this.radius = radius;
	}

	/**
	 * get the radius
	 * @return radius
	 */
	public int getRadius() {
		return radius;
	}
	
	public IUpdateStrategy getStraInterface() { 
		return strategyInterface;
		
	}
	

	
	public void updateState() {

	}


  public Component getContainer() {
    return container;
  }
}
